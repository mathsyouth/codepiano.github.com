---
layout: post
keywords: git
description: 收集 Git 的常用命令，以便随时查阅
title: "Git 常用命令"
categories: [tool]
tags: [Git]
group: archive
icon: git
---
{% include mathsyouth/setup %}


### OPNFV 提交 commit 操作

1. log in JIRA, create JIRA name and generate JIRA id
1. `git pull`
1. `git checkout -b new_branch_name`
1. `git add file_name`
1. `git commit -s`
1. Add JIRA name and JIRA id
1. `git review`
1. log in gerrit to add reviewers
1. Submit in gerrit after finishing review


### OPNFV 修改别人的 patch 操作

1. `git fetch ssh://mathsyouth@gerrit.opnfv.org:29418/dovetail refs/changes/55/22855/4 && git checkout FETCH_HEAD`
1. `git checkout -b new_branch_name`
1. `git add`
1. `git commit --amend --reset-author` (或者 `git commit --amend --author "mathsyouth <linghui.zeng@huawei.com>")`
1. `git review`


### 本地仓库

* 本地创建新仓库
  1. `git init file_name`
  1. `cd file_name`
  1. 生成.git目录，`ls -al`命令查询
* 克隆镜像，所有本地分支默认与远程主机的同名分支建立跟踪关系，比如，本地的master分支自动追踪origin/master分支: `git clone <url> <本地目录名>`
* 手动建立追踪关系: `git branch --set-upstream-to=<remote>/branch_name branch_name` 指定本地 `branch_name` 分支追踪 `<remote>/branch_name` 分支


### 分支管理

* 创建分支: `git branch new_branch_name`
* 切换分支: `git checkout branch_name`
* 获取 Git 打好的 tag 所对应的代码: `git checkout tag_name`
* 查看分支
  - `git branch -r` （远程）
  - `git branch -a` （所有）
  - `git branch`    （本地）
* 创建并切换到新分支: `git checkout -b new_branch_name`
* 删除分支: `git branch -d branch_name`
* 合并其他分支到当前分支（如：master): `git merge branch_name`


### 文件操作

* 添加新文件到缓存区（Index）: `git add file_name`
* 为了fix 2个 bug 修改同一个文件，但分开提交: `git add -p file_name`
* 提交文件到 HAED: `git commit -m "代码提交信息"`
* 重新修改 patch: `git commit --amend`
* 删除文件:
  * `git rm file_name`
  * `git commit -m "Remove file_name"`
  * `git rm –cached file_name` 从暂存中移除，但不删除文件
* 文件重命名: `git mv old_file new_file`
* 合并提交:
  * 想合并最后的两次提交: `git rebase -i HEAD~2` 与 `git add -p` 一样是交互式操作，它将询问你想要合并哪些提交。你 pick 最近的提交然后 squash (合并)旧的提交。
  * 如果你正在多个分支上并行工作，你也许会发现一个存在于所有分支上的 bug。如果你在某个分支上解决了这个 bug，你可以拣选这个对应的 commit 应用到其他分支上：在要应用 bug fix 的分支上执行： `git cherry-pick [已解决 bug 分支的 commit_hash]`


### 撤销操作

#### 修改最后一次提交

有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 `--amend` 选项重新提交：

```shell
git commit --amend
```

此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。

如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 `--amend` 提交：

```shell
git commit -m 'initial commit'
git add forgotten_file
git commit --amend
```

上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。


#### 丢弃工作区的修改

当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时, 用命令 `git checkout -- <file>`，这里有两种情况：

* 一种是 `file` 自修改后还没有被放到暂存区，丢弃修改就回到和版本库一模一样的状态；
* 一种是 `file` 已经添加到暂存区后，又作了修改，现在丢弃修改就回到添加到暂存区后的状态。

总之，就是让这个文件回到最近一次 `git commit` 或 `git add` 时的状态。


#### 取消已经暂存的文件

当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步撤消暂存文件 file:

```shell
git status
git reset HEAD <file>
```

现在 file 文件又回到了之前已修改未暂存的状态，第二步 `git checkout -- <file>`。


#### 丢弃提交

首先，Git 必须知道当前版本是哪个版本，在 Git 中，用 `HEAD` 表示当前版本，也就是最新的 commit 36281...，上一个版本就是 `HEAD^`，上上一个版本就是 `HEAD^^`，当然往上100个版本写100个^比较容易数不过来，所以写成 `HEAD~100`。现在，我们要把当前版本回退到上一个版本，可以使用命令：

```shell
git reset --hard HEAD^
```

commit 和 index 都回退到某个版本，自从 <commit> 以来在 working directory 中的任何改变都被丢弃，并把 HEAD 指向 <commit>。也可以使用命令：

```shell
git reset --soft HEAD^
```

保留源码，只回退到 commit 信息到某个版本。不涉及index的回退，如果还需要提交，直接commit即可。也可以使用命令：

```shell
git reset --mixed HEAD^
```

会保留源码，只是将 git commit 和 index 信息回退到了某个版本。

`git reset --mixed HEAD` 可撤销所有缓存改动，但是把它们保留在工作目录下。`git reset --hard HEAD` 可彻底删除没有提交的改动。

#### 重新提交

1. 当 commit 之后，发现代码没有提交完整，或者想重新编辑一下提交的 comment，执行 `git reset --soft HEAD^`。
1. `edit` 对当前工作目录下的文件做修改。
1. 使用 reset 之前那次 commit 的注释、作者、日期等信息重新提交 `git commit -a -c ORIG_HEAD`。当执行 `git reset` 命令时，Git 会把老的 HEAD 拷贝到文件 .git/ORIG_HEAD 中，在命令中可以使用 ORIG_HEAD 引用这个 commit。`git commit` 命令中 `-a` 参数的意思是告诉 Git 自动把所有修改的和删除的文件都放进 `stage area`，未被 Git 跟踪的文件不受影响。命令中 `-c` 或者 `-C` 意思是拿已经提交的 commit 对象中的信息（作者，提交者，注释，时间戳等）提交。


#### 修改历史提交

1. `git rebase -i HEAD~3` 表示要修改当前版本的倒数第三次状态。这个命令会显示三行 `pick:*******` 如果你要修改哪个，就把那行的 pick 改成 edit，然后退出。这时通过 `git log ` 你可以发现， Git 的最后一次提交已经变成你选的那个了。
1. `git commit --amend` 对 commit 进行修改。
1. 使用 `git rebase --continue`


#### 解除各个分支之间的依赖关系

1. `git rebase -i HEAD~5`，如果要和那个分支解除依赖，删除对应的 `pick:*******`
1. 重新提交 `git review`


### 日志管理

* 查看日志:
  * `git log`
  * `git log -p` 展开显示提交的内容差异；-2 显示最近两条； –stat 仅显示简要的增改行数统计；
  * `git log –pretty=oneline` 每个提交放在一行显示
  * `git log –graph –oneline –decorate` 可以以图形化的方式显示 branch 关系
  * 搜索 commit 消息：`git log --grep="Something in the message"`
  * 搜索内容第一次出现或删除的提交：`git log -S "TODO: Check for admin status"`
  * 按文件搜索： `git log lib/foo.rb`
* 显示当前的视图状态: `git status`
* 记录每一条历史命令: `git reflog`


###　储藏

当你正在做一项复杂的工作时, 发现了一个和当前工作不相关但是又很讨厌的　bug。 你这时想先修复 bug再做手头的工作, 那么就可以用 `git stash` 来保存当前的工作状态, 等你修复完 bug 后,执行 `git unstash` 操作就可以回到之前的工作里。


### 标签

* `git tag -l` 列出 tags
* `git show tag_name` 查看 tag 信息
* 为先前的提交加 tag：
  1. `git log –pretty=oneline`
  1. `git tag -a tag_name 9fceb02`
* `git push origin tag_name` 推送 tag 到远端仓库
* `git push origin –tags` 一次性推送所有tag


### 远程仓库

* 将本地的更新，推送到远程主机
  - `git push <remote> <本地branch>:<远程branch>`
  - `git push origin master` 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。
  - `git push origin` 将当前分支推送到origin主机的对应分支
  - `git push` 当前分支只有一个追踪分支
* 丢弃所有本地改动和提交，到服务器获取最新版本，并将本地主分支指向它:
  - `git fetch origin master`
  - `git reset --hard origin/master`
* 取回远程主机的代码到本地，不合并: `git fetch <remote> branch_name`


###　版本差异

* 比较不同版本文件差异的常用命令格式：
  - `git diff` 查看尚未暂存的文件更新了哪些部分
  - `git diff filename` 查看尚未暂存的某个文件更新了哪些
  - `git diff –cached`  查看已经暂存起来的文件和上次提交的版本之间的差异
  - `git diff –cached filename` 查看已经暂存起来的某个文件和上次提交的版本之间的差异
  - `git diff ffd98b291e0caa6c33575c1ef465eae661ce40c9 b8e7b00c02b95b320f14b625663fdecf2d63e74c` 查看某两个版本之间的差异
  - `git diff ffd98b291e0caa6c33575c1ef465eae661ce40c9:filename b8e7b00c02b95b320f14b625663fdecf2d63e74c:filename` 查看某两个版本的某个文件之间的差异


###　其他

#### 传输大文件

有时上传一些大文件（比如图片），会出现 fatal: The remote end hung up unexpectedly 的提示，这是由于 git/https 的缓冲设置导致，可以通过如下方式解决：

```
git config http.postBuffer 524288000
```


### 参考文档

1. [Git使用笔记](http://lingxiankong.github.io/blog/2014/07/18/git-notes/)
